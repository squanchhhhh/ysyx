1.搭建仿真环境

1.1 环境变量
在vim的命令模式下使用
```:s/bash/zsh/g```
将bash改为zsh

1.2 安装verilator

1.3 编写makefile
为makefile增加一行命令
``` verilator --cc ./vsrc/top.v --exe ./csrc/sim_main.cpp```

1.4 安装nvboard


2.数字电路实验

2.1选择器实验
用选择器模板实现一个2位4选1的选择器，如下图所示，选择器有5个2位输入端，分别为X0, X1, X2, X3和Y，输出端为F；X0, X1, X2, X3是四个2位的输入变量。输出F端受控制端Y的控制，选择其中的一个X输出，当Y = 00时，输出端输出X0，即F = X0；当Y = 01时，输出端输出X1，即F = X1；以此类推。
选择器代码（没有使用模板）：
```
module mux41c (
  //4个两位输入，一共8位
  input  [7:0] a,
  //两位选择信号
  input  [1:0] s,
  //两位输出信号
  output [1:0] y
);

  reg [1:0] mux_out;

  always @* begin
    case(s)
      2'b00: mux_out = a[1:0];
      2'b01: mux_out = a[3:2];
      2'b10: mux_out = a[5:4];
      2'b11: mux_out = a[7:6];
      default: mux_out = 2'b00; 
    endcase
  end

  assign y = mux_out;

endmodule
```
```
led.v
  // 实例化mux41b模块
  mux41c my_mux(
    .a(mux_a),
    .s(mux_s),
    .y(mux_y)
  );

  // assign ledr = {led[7:5], led[4:0] ^ btn, sw};
  assign ledr[1:0] = mux_y; // 将mux41b的输出连接到ledr[1:0]
```
问题：在top.v中使用了sw的前8位信号，但是实现二位四选一选择器需要用到10位信号，暂时不知道怎么绑定sw9和sw10。
解决：在nvboard的readme.md文件中指出了自动绑定文件的auto_bind.cpp，将SW8和SW9加入绑定函数，nvboard_bind_pin( &top->sw, 10,SW9,SW8, SW7, SW6, SW5, SW4, SW3, SW2, SW1, SW0);

完成实验1


2.2译码器和编码器
优先编码器可以使用for循环
```
module encode83p(
  input [7:0] x,
  input en,
  output reg z,        // 将 z 声明为 reg 类型
  output reg [2:0] y
);
  integer i;
  
  always @(x or en) begin
    if (en) begin
      y = 3'b000;     // 初始化 y
      z = 0;          // 初始化 z
      for (i = 0; i <= 7; i = i + 1) begin
        if (x[i] == 1) begin
          y = i[2:0];
          z = 1;     // 当找到有效输入时，设置 z = 1
        end
      end
    end else begin
      y = 3'b000;
      z = 0;
    end
  end
endmodule
```
调整seg.v
```
module seg(
  input clk,
  input rst,
  input [2:0] x,       // 输入选择信号，选择要显示的数码管模式
  input [2:0] code,    // 对应数码管的段码输入
  output [7:0] o_seg0, 
  output [7:0] o_seg1, 
  output [7:0] o_seg2, 
  output [7:0] o_seg3, 
  output [7:0] o_seg4,
  output [7:0] o_seg5, 
  output [7:0] o_seg6, 
  output [7:0] o_seg7  
);

  reg [7:0] segs [7:0]; 

  assign segs[0] = 8'b11111101;
  assign segs[1] = 8'b01100000;
  assign segs[2] = 8'b11011010;
  assign segs[3] = 8'b11110010;
  assign segs[4] = 8'b01100110;
  assign segs[5] = 8'b10110110;
  assign segs[6] = 8'b10111110;
  assign segs[7] = 8'b11100000;

  reg [2:0] selected_seg;

  always @ (posedge clk or posedge rst) begin
    if (rst) begin
      selected_seg <= 3'b000;
    end else begin
      case (x)
        3'b000: selected_seg <= 3'b000;
        3'b001: selected_seg <= 3'b001;
        3'b010: selected_seg <= 3'b010;
        3'b011: selected_seg <= 3'b011;
        3'b100: selected_seg <= 3'b100;
        3'b101: selected_seg <= 3'b101;
        3'b110: selected_seg <= 3'b110;
        3'b111: selected_seg <= 3'b111;
        default: selected_seg <= 3'b000; 
      endcase
    end
  end

  // 将选定的数码管的段码输出到对应的端口
  assign o_seg0 = (selected_seg == 3'b000) ? ~segs[code] : 8'b11111111;
  assign o_seg1 = (selected_seg == 3'b001) ? ~segs[code] : 8'b11111111;
  assign o_seg2 = (selected_seg == 3'b010) ? ~segs[code] : 8'b11111111;
  assign o_seg3 = (selected_seg == 3'b011) ? ~segs[code] : 8'b11111111;
  assign o_seg4 = (selected_seg == 3'b100) ? ~segs[code] : 8'b11111111;
  assign o_seg5 = (selected_seg == 3'b101) ? ~segs[code] : 8'b11111111;
  assign o_seg6 = (selected_seg == 3'b110) ? ~segs[code] : 8'b11111111;
  assign o_seg7 = (selected_seg == 3'b111) ? ~segs[code] : 8'b11111111;

endmodule

```
```
//对输入进行编码
encode83p my_encode(
    .en(sw[8]),
    .x(sw[7:0]),
    .y(y),
    .z(z)
);
assign ledr[2:0] = y;
assign ledr[4] = z;
seg my_seg(
    .clk(clk),
    .rst(rst),
    .x(0),
    .code(y),
    .o_seg0(seg0),
    .o_seg1(seg1),
    .o_seg2(seg2),
    .o_seg3(seg3),
    .o_seg4(seg4),
    .o_seg5(seg5),
    .o_seg6(seg6),
    .o_seg7(seg7)
);
```


3.1 alu
判断溢出和进位：
    对于无符号4位整数，表示范围是0-15，如果两个无符号整数相加出现了进位，说明发生了溢出。
    对于有符号4位整数，表示范围是-8～7，如果有进位则溢出，如果两个正数相加为负数，则溢出。




